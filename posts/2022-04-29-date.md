---
date: 2022-04-29
category: date, new Date
---

## Date 객체 잘 알고 써야 한다.

- 지역별로 타임존이 있다
- 이 타임존 반영이 javascript 에서 제대로 지원이 안되있다.
- new Date 는 그 컴퓨터가 설정된 혹은 브라우저 종류별로 혹은 서버나
- 프론트냐 아니냐에 따라서 node 버전에 따를 수도 있을 것 같아 어쨋은
- 결과를 반환한다.
- 그래서 신뢰성이 많이 떨어진다.
- 편한 해결 방법은 라이브러리를 사용하는 것이고 moment 과 date-fns-tz 추천
- 약간 불편한 방법은 그래도 계산하는 방법이다
- 문자열의 경우 toUTCString, 이나 뒤에 Z 를 붙이는 방법도 있는데 그렇게 쓸만한 방법 같지는 않았다(이것도 결국 바뀜 그냥 toString 하고 똑같음)

  ```
  먼저 원래 시간과 offset을 알아낸다(이것도 음수 양수 가 나오는데 역시 결과가 막 다르게 나온다)
  그래도 일단 offset은 분 단위로 나오는데 여기에 초(60) 밀리초(1000) 까지 곱해서 밀리초단위로 맞추고 기존 시간에 더하던가 뺀다.

  더하거나 뺀 값을 새로 데이터 객체로 바꿔주면된다.

  const dateToString = "2022-10-10 10:10:10"
  const messDate = new Date(dateToString);
  const offset = messDate.getTimezoneOffset();
  const curTime = messDate().getTime()  +  or - offset*1000*60

  cosnt result = new Date(curTime);

  //나 같은 경우
  //프론트 서버에서는 +를 해야 했다.
  //백엔드 서버에서는 -를 해야 했다.
  //콘솔 찍어보고 맞는 방향으로 더하거나 빼면 된다.

  ```

  - 위 내용도 결국 한개의 프론트 서버에서 와 백엔드 서버에서와 환경차이때문에 발생하는 문제다.
  - 그래서 환경을 같게 맞춰주거나 시간을 구하는 기준을 정해서 맞출 필요가 있었다.
  - 일단은 console.log 찍으면서 차이만큼 더하고 빼면서 해결해 주었지만
  - 기본적으로 같은 환경이면 그리 크게 신경쓰지 않고 작업해도 되며
  - 서버로 (다른환경으로) 데이터를 보낼때 그리고 받은 데이터를 다시 되돌려 보내는 부분을 신경쓰면 될 것 같다.
