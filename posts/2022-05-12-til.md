---
date: 2022-05-12
category: til
---

## 오늘 한 일

- 알고리즘(프로그래머스 피로도 풀음)
  - 항상 그러했듯, 풀다 실패하고 막혀서 다른사람 풀이보고 힌트를 얻어서 풀었다.
  - 조합, dfs 방법 외 완전탐색 방법으로 풀은 사람이 있던데 아직 완전탐색은 못 봤다.
- recoil 학습(지금 작성한 레코일 코드 많이 고쳐야 겠다)
  - atomFamily, atomEffect 기능을 살펴봤다.
- 영화검색 프로젝트(이제 무한스크롤 조금 이해가 된다)
  - ref 나를 힘들게 했는데 이제 대략적으로 규칙이 보인다.
  - recoil 공부를 하고나니 recoil 코드를 고쳐야 겠다는 고민을 했다.

## 어려운점

- 알고리즘 풀 때 어떤 방식으로 풀어야 할지, 이게 무슨문제인지 아직 감이 안온다.
  - 풀다가 막혀서 고민하고, 방법을 자꾸 바꿔가면서 계속 풀고 있다.
  - 그리고 시간이 오래 걸린다 싶으면 다른사람 풀이를 참고 하고 있다.
  - 아예 이해도 못해서 허둥대던때 보다는 나은 것 같지만 아직 갈길이 멀다고 생각한다.
  - 그래도 알고리즘은 꾸준히 해야 겠다.
- recoil 작성 패턴을 찾다가 강의를 하나 확인해서 들어보았다.
  - 우와... 나는 레코일 코드를 잘못 짜고 있었다.
  - 기능도 잘못 이해하고 있었고,,, atomFamily 를 써야 하는 곳이 많았는데...
  - atomFamily 는 스테이트를 여러개 만들 것을 하나만 만들어서 고유값을 유지하게 해준다.
  - 또 구독을 할때 해당 파라미터의 아톰만 구독하므로 성능상에 이점이 있다.
  - 비슷한 스테이트가 있으면 일일히 나누거나 합쳐서 객체로 만들 생각을 하는데
  - recoil 은 atomFamily 를 제공해 줘서 짧은 코드고 효율적인 개발을 하게 도외준다
  - atomEffect 는 atom 에 useEffect를 붙인다고 생각하면 될듯하다.
  - 아직 궁금한 점은 해당 아톰 범위에서만 작동하는건지
  - 다른 아톰에 접근해서 조작 할 수도 있는 건지는 궁금하다.
  - effect_UNSTABLE 속성을 붙여서 사용하고 함수가 담긴 배열을 만들면된다.
  - 함수 하나하나에 파라미터에 onset, selfset, target, node 가 담겨있다.
  - onset 은 아톰 내용이 바뀔데 할 일을 적으면된다.
  - selfset 은 처음 아톰이 생성될때 넣을 초기값을 넣어주는 녀석이다.
  - target 은 "get" "set"이 있는데 각 유형별로 할 동작을 분기 할 수 있고
  - node 는 key 로 설정한 고유값을 가르키는데 atomFamily 에서 받은 파라미터가 자동으로 붙는다
  - cache 를 별도로 만들어서 비동기 식으로 onset selfset을 처리 할 수 있는데
  - 만든 캐쉬에 값이 이미 담겨있는지 확인하면서 캐슁 작업을 해줄 수도 있다.
- 영화검색 프로젝트
  - ref 의 규칙은
    - refCallback 은 같은 컴포넌트(자식도 안됨)내에서만 깨체를 담을 수 있다.
    - refCallback 은 같은 컴포넌트더라도 map 으로 순회하고 있는 요소에 넣을 수 없다.
    - 위 내용을 어기면 무한랜더링(결국 스테이트에 값을 그 컴포넌트에서 바꿧으니..)일어남
    - 위 두가지 제약을 벗어나려먼 refCallback 함수에서 세팅하는 스테이트에 원시값을 담던가
    - useRef 를 사용해서 공식문서에 나온대로 사용하면된다.
    - useRef 값도 같은 컴포넌트 에서만 값이 변할때 리랜더링이 제대로 되서 작동한다.
      - 자식 컴포넌트에 전달하면 작동 안한다고 보면된다.(map 으로 순회하는 요소에는 작동한다)
    - useRef 가 작동 자식 컴포넌트에 전달했을때 작동 안되는 것을 보고 정말 이해가 되지 않았다. 하지만 정말 리랜더링이 안일어난다.
    - ref 에 값이 들어가는 시점은 componentdidmount componentupdatemount 되기 전이라고 한다.
    - 즉 랜더링이 일어나고 해당 매서드 2개가 작동하기 전에 값이 들어가야 되는데
    - 매서드가 작동한 다음에 값이 들어가버리면 무한랜더링
    - 아니면 랜더링 전에 값이 들어가 버리면 그냥 리랜더링이 안 일어나는 것 같았다.
    - 그래서 리엑트에서 제시한 방법을 지켜서 사용을 해야겠다고 생각했고,
    - 솔직히 refCallback으로 객체를 집어 넣는 방법도 꼼수 라서 언제 막힐 지 모른다는 생각을 했다.(useCallback 에 dep 를 안넣어서 랜더링을 막는 방법인데 객체 가 들어가면 랜더링 일어남. 하지만 어쩐 일인지 같은 컴포넌트 안에서는 리랜더링이 일어나지 않았다.)

## 해야 할 일

- 무한스크롤을 atomEffect로 다시 구현하기
- 컴포넌트에 전달할 loading을 담을 아톰을 정해서 컴포넌트에 제공할 것
- 그런데 아직 방법을 잘 이해하지 못하고 있음(아톰에서 다른아톰 에 쓰기가 가능한지? 등)

1. recoil 강의 한번 정독 할 것
2. recoil 코드 싹 갈아 엎을 것!!
